{"filter":false,"title":"three.STLLoader.js","tooltip":"/public/js/three.STLLoader.js","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":432,"column":1},"action":"insert","lines":["/**"," * @author aleeper / http://adamleeper.com/"," * @author mrdoob / http://mrdoob.com/"," * @author gero3 / https://github.com/gero3"," *"," * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs."," *"," * Supports both binary and ASCII encoded files, with automatic detection of type."," *"," * Limitations:"," *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL)."," *  There is perhaps some question as to how valid it is to always assume little-endian-ness."," *  ASCII decoding assumes file is UTF-8. Seems to work for the examples..."," *"," * Usage:"," *  var loader = new THREE.STLLoader();"," *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {"," *    scene.add( new THREE.Mesh( geometry ) );"," *  });"," *"," * For binary STLs geometry might contain colors for vertices. To use it:"," *  // use the same code to load STL as above"," *  if (geometry.hasColors) {"," *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });"," *  } else { .... }"," *  var mesh = new THREE.Mesh( geometry, material );"," */","","","THREE.STLLoader = function ( manager ) {","","\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;","","};","","THREE.STLLoader.prototype = {","","\tconstructor: THREE.STLLoader,","","\tload: function ( url, onLoad, onProgress, onError ) {","","\t\tvar scope = this;","","\t\tvar loader = new THREE.XHRLoader( scope.manager );","\t\tloader.setCrossOrigin( this.crossOrigin );","\t\tloader.setResponseType('arraybuffer');","\t\tloader.load( url, function ( text ) {","","\t\t\tonLoad( scope.parse( text ) );","","\t\t}, onProgress, onError );","","\t},","\t","\tparse: function ( data ) {","","\t\tvar isBinary = function () {","","\t\t\tvar expect, face_size, n_faces, reader;","\t\t\treader = new DataView( binData );","\t\t\tface_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);","\t\t\tn_faces = reader.getUint32(80,true);","\t\t\texpect = 80 + (32 / 8) + (n_faces * face_size);","\t\t\t","\t\t\tif ( expect === reader.byteLength ) {","\t\t\t\t","\t\t\t\treturn true;","\t\t\t\t","\t\t\t}","","\t\t\t// some binary files will have different size from expected,","\t\t\t// checking characters higher than ASCII to confirm is binary","\t\t\tvar fileLength = reader.byteLength;","\t\t\tfor ( var index = 0; index < fileLength; index ++ ) {","","\t\t\t\tif ( reader.getUint8(index, false) > 127 ) {","\t\t\t\t\t","\t\t\t\t\treturn true;","\t\t\t\t\t","\t\t\t\t}","","\t\t\t}","","\t\t\treturn false;","","\t\t};","","\t\tvar binData = this.ensureBinary( data );","","\t\treturn isBinary()","\t\t\t? this.parseBinary( binData )","\t\t\t: this.parseASCII( this.ensureString( data ) );","","\t},","","\tparseBinary: function ( data ) {","","\t\tvar reader = new DataView( data );","\t\tvar faces = reader.getUint32( 80, true );","","\t\tvar r, g, b, hasColors = false, colors;","\t\tvar defaultR, defaultG, defaultB, alpha;","","\t\t// process STL header","\t\t// check for default color in header (\"COLOR=rgba\" sequence).","","\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {","","\t\t\tif ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&","\t\t\t\t(reader.getUint8(index + 4) == 0x52 /*'R'*/) &&","\t\t\t\t(reader.getUint8(index + 5) == 0x3D /*'='*/)) {","","\t\t\t\t\thasColors = true;","\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3);","","\t\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;","\t\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;","\t\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;","\t\t\t\t\talpha = reader.getUint8(index + 9) / 255;","\t\t\t\t}","\t\t\t}","","\t\tvar dataOffset = 84;","\t\tvar faceLength = 12 * 4 + 2;","","\t\tvar offset = 0;","","\t\tvar geometry = new THREE.BufferGeometry();","","\t\tvar vertices = new Float32Array( faces * 3 * 3 );","\t\tvar normals = new Float32Array( faces * 3 * 3 );","","\t\tfor ( var face = 0; face < faces; face ++ ) {","","\t\t\tvar start = dataOffset + face * faceLength;","\t\t\tvar normalX = reader.getFloat32(start, true);","\t\t\tvar normalY = reader.getFloat32(start + 4, true);","\t\t\tvar normalZ = reader.getFloat32(start + 8, true);","","\t\t\tif (hasColors) {","","\t\t\t\tvar packedColor = reader.getUint16(start + 48, true);","","\t\t\t\tif ((packedColor & 0x8000) === 0) { // facet has its own unique color","","\t\t\t\t\tr = (packedColor & 0x1F) / 31;","\t\t\t\t\tg = ((packedColor >> 5) & 0x1F) / 31;","\t\t\t\t\tb = ((packedColor >> 10) & 0x1F) / 31;","\t\t\t\t} else {","","\t\t\t\t\tr = defaultR;","\t\t\t\t\tg = defaultG;","\t\t\t\t\tb = defaultB;","\t\t\t\t}","\t\t\t}","","\t\t\tfor ( var i = 1; i <= 3; i ++ ) {","","\t\t\t\tvar vertexstart = start + i * 12;","","\t\t\t\tvertices[ offset     ] = reader.getFloat32( vertexstart, true );","\t\t\t\tvertices[ offset + 1 ] = reader.getFloat32( vertexstart + 4, true );","\t\t\t\tvertices[ offset + 2 ] = reader.getFloat32( vertexstart + 8, true );","","\t\t\t\tnormals[ offset     ] = normalX;","\t\t\t\tnormals[ offset + 1 ] = normalY;","\t\t\t\tnormals[ offset + 2 ] = normalZ;","","\t\t\t\tif (hasColors) {","\t\t\t\t\tcolors[ offset     ] = r;","\t\t\t\t\tcolors[ offset + 1 ] = g;","\t\t\t\t\tcolors[ offset + 2 ] = b;","\t\t\t\t}","","\t\t\t\toffset += 3;","","\t\t\t}","","\t\t}","","\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );","\t\tgeometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );","","\t\tif (hasColors) {","\t\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );","\t\t\tgeometry.hasColors = true;","\t\t\tgeometry.alpha = alpha;","\t\t}","","\t\treturn geometry;","","\t},","","\tparseASCII: function ( data ) {","","\t\tvar geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;","\t\tgeometry = new THREE.Geometry();","\t\tpatternFace = /facet([\\s\\S]*?)endfacet/g;","","\t\twhile ( ( result = patternFace.exec( data ) ) !== null ) {","","\t\t\ttext = result[0];","\t\t\tpatternNormal = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;","","\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {","","\t\t\t\tnormal = new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );","","\t\t\t}","","\t\t\tpatternVertex = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g;","","\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {","","\t\t\t\tgeometry.vertices.push( new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) ) );","","\t\t\t}","","\t\t\tlength = geometry.vertices.length;","","\t\t\tgeometry.faces.push( new THREE.Face3( length - 3, length - 2, length - 1, normal ) );","","\t\t}","","\t\tgeometry.computeBoundingBox();","\t\tgeometry.computeBoundingSphere();","","\t\treturn geometry;","","\t},","","\tensureString: function ( buf ) {","","\t\tif (typeof buf !== \"string\"){","\t\t\tvar array_buffer = new Uint8Array(buf);","\t\t\tvar str = '';","\t\t\tfor(var i = 0; i < buf.byteLength; i++) {","\t\t\t\tstr += String.fromCharCode(array_buffer[i]); // implicitly assumes little-endian","\t\t\t}","\t\t\treturn str;","\t\t} else {","\t\t\treturn buf;","\t\t}","","\t},","","\tensureBinary: function ( buf ) {","","\t\tif (typeof buf === \"string\"){","\t\t\tvar array_buffer = new Uint8Array(buf.length);","\t\t\tfor(var i = 0; i < buf.length; i++) {","\t\t\t\tarray_buffer[i] = buf.charCodeAt(i) & 0xff; // implicitly assumes little-endian","\t\t\t}","\t\t\treturn array_buffer.buffer || array_buffer;","\t\t} else {","\t\t\treturn buf;","\t\t}","\t\t","\t}","","};","","if ( typeof DataView === 'undefined'){","","\tDataView = function(buffer, byteOffset, byteLength){","","\t\tthis.buffer = buffer;","\t\tthis.byteOffset = byteOffset || 0;","\t\tthis.byteLength = byteLength || buffer.byteLength || buffer.length;","\t\tthis._isString = typeof buffer === \"string\";","","\t}","","\tDataView.prototype = {","","\t\t_getCharCodes:function(buffer,start,length){","\t\t\tstart = start || 0;","\t\t\tlength = length || buffer.length;","\t\t\tvar end = start + length;","\t\t\tvar codes = [];","\t\t\tfor (var i = start; i < end; i++) {","\t\t\t\tcodes.push(buffer.charCodeAt(i) & 0xff);","\t\t\t}","\t\t\treturn codes;","\t\t},","","\t\t_getBytes: function (length, byteOffset, littleEndian) {","","\t\t\tvar result;","","\t\t\t// Handle the lack of endianness","\t\t\tif (littleEndian === undefined) {","","\t\t\t\tlittleEndian = this._littleEndian;","","\t\t\t}","","\t\t\t// Handle the lack of byteOffset","\t\t\tif (byteOffset === undefined) {","","\t\t\t\tbyteOffset = this.byteOffset;","","\t\t\t} else {","","\t\t\t\tbyteOffset = this.byteOffset + byteOffset;","","\t\t\t}","","\t\t\tif (length === undefined) {","","\t\t\t\tlength = this.byteLength - byteOffset;","","\t\t\t}","","\t\t\t// Error Checking","\t\t\tif (typeof byteOffset !== 'number') {","","\t\t\t\tthrow new TypeError('DataView byteOffset is not a number');","","\t\t\t}","","\t\t\tif (length < 0 || byteOffset + length > this.byteLength) {","","\t\t\t\tthrow new Error('DataView length or (byteOffset+length) value is out of bounds');","","\t\t\t}","","\t\t\tif (this.isString){","","\t\t\t\tresult = this._getCharCodes(this.buffer, byteOffset, byteOffset + length);","","\t\t\t} else {","","\t\t\t\tresult = this.buffer.slice(byteOffset, byteOffset + length);","","\t\t\t}","","\t\t\tif (!littleEndian && length > 1) {","","\t\t\t\tif (!(result instanceof Array)) {","","\t\t\t\t\tresult = Array.prototype.slice.call(result);","","\t\t\t\t}","","\t\t\t\tresult.reverse();","\t\t\t}","","\t\t\treturn result;","","\t\t},","","\t\t// Compatibility functions on a String Buffer","","\t\tgetFloat64: function (byteOffset, littleEndian) {","","\t\t\tvar b = this._getBytes(8, byteOffset, littleEndian),","","\t\t\t\tsign = 1 - (2 * (b[7] >> 7)),","\t\t\t\texponent = ((((b[7] << 1) & 0xff) << 3) | (b[6] >> 4)) - ((1 << 10) - 1),","","\t\t\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead","\t\t\t\tmantissa = ((b[6] & 0x0f) * Math.pow(2, 48)) + (b[5] * Math.pow(2, 40)) + (b[4] * Math.pow(2, 32)) +","\t\t\t\t\t\t\t(b[3] * Math.pow(2, 24)) + (b[2] * Math.pow(2, 16)) + (b[1] * Math.pow(2, 8)) + b[0];","","\t\t\tif (exponent === 1024) {","\t\t\t\tif (mantissa !== 0) {","\t\t\t\t\treturn NaN;","\t\t\t\t} else {","\t\t\t\t\treturn sign * Infinity;","\t\t\t\t}","\t\t\t}","","\t\t\tif (exponent === -1023) { // Denormalized","\t\t\t\treturn sign * mantissa * Math.pow(2, -1022 - 52);","\t\t\t}","","\t\t\treturn sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);","","\t\t},","","\t\tgetFloat32: function (byteOffset, littleEndian) {","","\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian),","","\t\t\t\tsign = 1 - (2 * (b[3] >> 7)),","\t\t\t\texponent = (((b[3] << 1) & 0xff) | (b[2] >> 7)) - 127,","\t\t\t\tmantissa = ((b[2] & 0x7f) << 16) | (b[1] << 8) | b[0];","","\t\t\tif (exponent === 128) {","\t\t\t\tif (mantissa !== 0) {","\t\t\t\t\treturn NaN;","\t\t\t\t} else {","\t\t\t\t\treturn sign * Infinity;","\t\t\t\t}","\t\t\t}","","\t\t\tif (exponent === -127) { // Denormalized","\t\t\t\treturn sign * mantissa * Math.pow(2, -126 - 23);","\t\t\t}","","\t\t\treturn sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);","\t\t},","","\t\tgetInt32: function (byteOffset, littleEndian) {","\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian);","\t\t\treturn (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | b[0];","\t\t},","","\t\tgetUint32: function (byteOffset, littleEndian) {","\t\t\treturn this.getInt32(byteOffset, littleEndian) >>> 0;","\t\t},","","\t\tgetInt16: function (byteOffset, littleEndian) {","\t\t\treturn (this.getUint16(byteOffset, littleEndian) << 16) >> 16;","\t\t},","","\t\tgetUint16: function (byteOffset, littleEndian) {","\t\t\tvar b = this._getBytes(2, byteOffset, littleEndian);","\t\t\treturn (b[1] << 8) | b[0];","\t\t},","","\t\tgetInt8: function (byteOffset) {","\t\t\treturn (this.getUint8(byteOffset) << 24) >> 24;","\t\t},","","\t\tgetUint8: function (byteOffset) {","\t\t\treturn this._getBytes(1, byteOffset)[0];","\t\t}","","\t };","","}"]}]}]]},"ace":{"folds":[],"scrolltop":5813,"scrollleft":0,"selection":{"start":{"row":432,"column":1},"end":{"row":432,"column":1},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":1051,"mode":"ace/mode/javascript"}},"timestamp":1426079062738,"hash":"ee4135fcc48182369a8ab8cddea67eefd14b2ae1"}